struct PSINPUT {
	float4 position : SV_POSITION;
	float2 uv : TEXCOORD0;
};

struct PSOUTPUT {
	float4 color : SV_Target0;
};

#define RG_SMAPLE_LEVEL 0

Texture2D t_unit0 : register(t0);
Texture2D t_unit1 : register(t1);
Texture2D t_unit2 : register(t2);
Texture2D t_unit3 : register(t3);
Texture2D t_unit4 : register(t4);
SamplerState SampleType : register(s0);

cbuffer ConstBuffer : register(b0) {
	row_major float4x4 proj;
	row_major float4x4 view;
	row_major float4x4 viewProj;
	row_major float4x4 invProj;
	row_major float4x4 invView;
	float4 camera_position;
	int screen_size;
};

float GetDepth(float2 uv) {
	return t_unit4.SampleLevel(SampleType, uv, RG_SMAPLE_LEVEL).r;
}

bool IsOutside(float2 ray) {
	return (ray.x > 1 || ray.y > 1 || ray.x < 0 || ray.y < 0) ? true : false;
}

// World-space to screen-space (NDC)
float4 Project(float4 pos) {
	float4 v = mul(pos, viewProj);
	return v / v.w;
}

float3 TraceRay(float3 wpos, float3 refl) {
	float maxRayDistance = 20;

	float  stepsize = 0.1f;
	int    steps    = 100;

	float3 startpos = wpos;
	float3 pos      = startpos;

	for(int i = 0; i < steps; i++) {
		pos = pos + refl * stepsize;
		float3 projected = Project(float4(pos, 1)).xyz;
		float2 _uv = projected.xy * 0.5 + 0.5;
		_uv.y = 1 - _uv.y;

		if(IsOutside(_uv)) {
			// Out of bounds
			return 0;
		}
		
		float proj_depth   = projected.z;   // Projected depth
		float sample_depth = GetDepth(_uv); // Sample depth
		
		float diff = proj_depth - sample_depth;
		if(diff >= 0 && diff < 0.01) {
			// Hit
			return t_unit3.Sample(SampleType, _uv).rgb;
		}
	}

	// Miss
	return 0;
}

PSOUTPUT pmain(PSINPUT psin, float4 fragCoord : SV_Position) {

	int screenx = screen_size >> 16;
	int screeny = screen_size & 0x0000FFFF;
	
	float2 noproj_uv = fragCoord.xy/float2(screenx, screeny);


	float4 alb_met = t_unit0.Sample(SampleType, noproj_uv);
	float4 nor_rou = t_unit1.Sample(SampleType, noproj_uv);
	float4 wps_emi = t_unit2.Sample(SampleType, noproj_uv);

	float4 lightres = t_unit3.Sample(SampleType, noproj_uv);
	
	float3 albedo    = alb_met.rgb;
	float3 normal    = normalize(nor_rou.xyz);
	float3 wpos      = wps_emi.xyz;
	float  metallic  = alb_met.a;
	float  roughness = nor_rou.a;
	float  emissive  = wps_emi.a;

	float3 viewVector = normalize(wpos - camera_position.xyz);
	float3 reflection = normalize(reflect(viewVector, normal));

	float  fresnel    = 1 - max(0, dot(-viewVector, normal));

	float reflectivity = fresnel * (1 - roughness); // TMP

	float3 tColor = TraceRay(wpos, reflection) * reflectivity;

	if(tColor.r < 0.001 && tColor.g < 0.001 && tColor.b < 0.001) {
		tColor = lightres.rgb;
	}



	PSOUTPUT pout;
	//pout.color.rgb = tColor;
	pout.color.rgb = lightres.rgb*roughness + (1-roughness)*tColor;
	pout.color.a   = 1;
	return pout;


#if 0

	float maxRayDistance = 20;

	float3 pixelPosition = 0;
	pixelPosition.xy = noproj_uv;

	// View normal
	float3 normalView = GetViewNormal(pixelPosition.xy);
	float pixelDepth = GetDepth(pixelPosition.xy);
	pixelPosition.z = pixelDepth;

	//invProj * invView;

	//float4 _ss =  = mul(float4(pixelPosition * float3(2, 2, 1) - float3(1, 1, 0), 1), invProj);

	//float4 posView = mul(float4(pixelPosition * float3(2, 2, 1) - float3(1, 1, 0), 1), invVP);
	float4 NDC = float4(pixelPosition * float3(2, 2, 1) - float3(1, 1, 0), 1);

	float4 _cs = mul(NDC, invProj); // Camera space
	_cs.w = 1;
	float4 _ws = mul(_cs, invView); // World space

	float4 posView = _ws;
	posView /= posView.w;

	float3 reflection = normalize(reflect(posView.xyz, normalView));
	//if(reflection.z > 0) {
	//	discard;
	//}

	float3 rayEndPositionView = posView.xyz + reflection * maxRayDistance;

	float4 rayEndPosition = mul(float4(rayEndPositionView, 1), proj);
	rayEndPosition /= rayEndPosition.w;
	rayEndPosition.xyz = (rayEndPosition.xyz + 1) / 2;
	float3 rayDirection = rayEndPosition.xyz - pixelPosition;

	int2 ssStartPos = int2(pixelPosition.x * screenx, pixelPosition.y * screeny);
	int2 ssEndPos   = int2(rayEndPosition.x * screenx, rayEndPosition.y * screeny);
	int2 ssDistance = ssEndPos - ssStartPos;
	uint ssMaxDist  = uint(max(abs(ssDistance.x), abs(ssDistance.y))) / 2;
	rayDirection /= max(ssMaxDist, 0.001);

	//float3 tColor = pixelDepth;//TraceRay(pixelPosition, rayDirection, ssMaxDist);
	//float3 tColor = TraceRay(pixelPosition, rayDirection, ssMaxDist);
	float3 tColor = posView;

	PSOUTPUT pout;
	pout.color.rgb = tColor;
	pout.color.a   = 1;
	return pout;
#endif
}