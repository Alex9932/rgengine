static String txt_VertexShader = "#version 330 core\n"
"#define MAX_BONES 1024\n" // Huyarim na vse babki xD
"layout (location = 0) in vec3  v_pos;\n"
"layout (location = 1) in vec3  v_norm;\n"
"layout (location = 2) in vec3  v_tang;\n"
"layout (location = 3) in vec2  v_uv;\n"
"layout (location = 4) in vec4  v_weight;\n"
"layout (location = 5) in ivec4 v_bidx;\n"
"out vec3 o_pos;\n"
"out vec3 o_norm;\n"
"out vec3 o_tang;\n"
"out vec2 o_uv;\n"
"out mat3 o_TBN;\n"
"uniform mat4 proj;\n"
"uniform mat4 view;\n"
"uniform mat4 mdl;\n"
"uniform int  animDisable;\n"
"layout (std140) uniform BoneMatrices {\n"
"    mat4 bone_matrices[MAX_BONES];\n"
"};\n"
"void main() {\n"
"    vec4 total_position = vec4(0);\n"
"    vec3 total_normal   = vec3(0);\n"
"    vec3 total_tangent  = vec3(0);\n"
"    bool hasTransform = false;\n"
"    vec4 pos4 = vec4(v_pos, 1);\n"
"    for(int i = 0 ; i < 4; i++) {\n"
"        float w    = v_weight[i];\n"
"        int   id   = v_bidx[i];\n"
"        if (id < 0 || id >= MAX_BONES) {\n"
"            continue;\n"
"        }\n"
"        hasTransform = true;\n"
"        mat4 m4 = bone_matrices[id];\n"
//"        mat3 m3 = mat3(m4);"
"        mat3 m3 = transpose(inverse(mat3(m4)));\n"
"        vec4 localPosition = m4 * pos4;\n"
"        vec3 localNormal   = m3 * v_norm;\n"
"        vec3 localTangent  = m3 * v_tang;\n"
"        total_position += localPosition * w;\n"
"        total_normal   += localNormal   * w;\n"
"        total_tangent  += localTangent  * w;\n"
"        total_normal = normalize(total_normal);\n"
"    }\n"
"    // Do not animate this vertex\n"
"    if (!hasTransform || animDisable != 0) {\n"
"        total_position = pos4;\n"
"        total_normal   = v_norm;\n"
"        total_tangent  = v_tang;\n"
"    }\n"
#if 1
//"    mat3 vmat = mat3(mdl);\n"
"    mat3 vmat = transpose(inverse(mat3(mdl)));\n"
"    vec3 N = normalize(vmat * total_normal);\n"
"    vec3 T = normalize(vmat * total_tangent);\n"
"    T = normalize(T - dot(T, N) * N);\n"
"    vec3 B = normalize(cross(N, T));\n"
"    o_TBN  = mat3(T, B, N);\n"
"    o_pos  = (mdl * total_position).xyz;\n"
"    o_norm = N;\n"
"    o_tang = T;\n"
"    o_uv   = v_uv;\n"
"    gl_Position = proj * view * vec4(o_pos, 1);\n"
#else
"    mat4 vp = proj * view;\n"
"    vec4 pos4 = vec4(v_pos, 1);\n"
"    vec4 nrm4 = vec4(v_norm, 0);\n"
"    vec4 tan4 = vec4(v_tang, 0);\n"
"    vec3 N = (nrm4 * mdl).xyz;\n"
"    vec3 T = (tan4 * mdl).xyz;\n"
"    vec3 B = normalize(cross(N, T));\n"
"    o_TBN  = mat3(T, B, N);\n"
"    o_pos  = (mdl * pos4).xyz;\n"
"    o_norm = N;\n"
"    o_tang = T;\n"
"    o_uv   = v_uv;\n"
"    gl_Position = vp * vec4(o_pos, 1);\n"
#endif
"}\n";

static String txt_PixelShader = "#version 330 core\n"
"in vec3 o_pos;\n"
"in vec3 o_norm;\n"
"in vec3 o_tang;\n"
"in vec2 o_uv;\n"
"in mat3 o_TBN;\n"
"out vec4 p_color;\n"
"uniform sampler2D t_unit0;\n"
"uniform sampler2D t_unit1;\n"
"uniform sampler2D t_unit2;\n"
"uniform vec3 viewpos;\n"
"uniform vec3 mat_color;\n"
"uniform int calclight;\n"
"uniform int flipuv;\n"
"#define PI 3.14159265359\n"
"float DistributionGGX(vec3 N, vec3 H, float roughness) {\n"
"    float a = roughness * roughness;\n"
"    float a2 = a * a;\n"
"    float NdotH = max(dot(N, H), 0.0);\n"
"    float NdotH2 = NdotH * NdotH;\n"
"    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n"
"    return a2 / (PI * denom * denom);\n"
"}\n"
"float GeometrySchlickGGX(float NdotV, float roughness) {\n"
"    float r = (roughness + 1.0);\n"
"    float k = (r * r) / 8.0;\n"
"    return NdotV / (NdotV * (1.0 - k) + k);\n"
"}\n"
"float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n"
"    float NdotV = max(dot(N, V), 0.0);\n"
"    float NdotL = max(dot(N, L), 0.0);\n"
"    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n"
"    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n"
"    return ggx1 * ggx2;\n"
"}\n"
"vec3 FresnelSchlick(float cosTheta, vec3 F0) {\n"
"    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n"
"}\n"
"\n"
// N - normal; V - Viewdir; P - World-space position; R - Roughness; M - metallic; A - albedo
"vec3 CalculateLight(vec3 N, vec3 V, vec3 P, float M, float R, vec3 A) {\n"
"    vec3 ambient = vec3(0.03) * A * (1.0 - M);\n"
"    vec3 L = normalize(vec3(0, 0.2, 1.8));\n"
"    vec3 C = vec3(1, 0.9, 0.8) * 1.8;\n"
"    vec3 Lo = vec3(0.0);\n"
"    vec3 H = normalize(V + L);\n"
// Do not calculate attenuation
"    vec3 radiance = C;\n"
"    float NDF = DistributionGGX(N, H, R);\n"
"    float G = GeometrySmith(N, V, L, R);\n"
"    vec3 F0 = mix(vec3(0.04), A, M);\n"
"    vec3 F = FresnelSchlick(max(dot(H, V), 0.0), F0);\n"
"    vec3 kS = F;\n"
//"    vec3 kD = vec3(1.0) - kS;\n"
//"    kD *= 1.0 - M;\n"
"    vec3 kD = (vec3(1.0) - kS) * (1.0 - M);"
"    vec3 numerator = NDF * G * F;\n"
"    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;\n"
"    vec3 specular = numerator / denominator;\n"
"    float NdotL = max(dot(N, L), 0.0);\n"
"    Lo += (kD * A / PI + specular) * radiance * NdotL;\n"
"    return ambient + Lo;\n"
"}\n"
"\n"
"void main() {\n"
"    vec2 c_uv = o_uv - (2 * o_uv * flipuv);\n"
"    vec4 alb = texture(t_unit0, c_uv);\n"
"    vec4 nrm = texture(t_unit1, c_uv);\n"
"    vec4 pbr = texture(t_unit2, c_uv);\n"
"    vec3 N;\n"
"#if 0\n"
"    N = normalize(nrm.xyz * 2.0 - 1.0);\n"
"    N = normalize(N * o_TBN);\n"
"#else\n"
"    N = normalize(o_norm);\n" // Disable normal mappings
"#endif\n"
//"    N.z = -N.z;\n"
"    vec3 V = normalize(viewpos - o_pos);\n"
"    vec3 light = vec3(1);\n"
"    if(calclight > 0) {\n"
"        light = vec3(0.0);\n"
"        light += CalculateLight(N, V, o_pos, pbr.x, pbr.y, alb.xyz);\n"
"    }\n"
"    p_color = vec4(alb.xyz * mat_color * light, 1);\n"
"    float gamma = 2.2;\n"
"    p_color.rgb = pow(p_color.rgb, vec3(1.0 / gamma));\n"
//"    p_color = vec4(N.xyz * 0.5 + 0.5, 1);\n"
"}\n";